--[=[

  ver. 1.02, 2005.01.08

  -- Добавлен вывод номера строки для команд, оставшихся на стеке

  ver. 1.03, 2005.01.09

  -- Убрана обработка метакоманд
  -- Изменен синтаксис команд с аргументами

  ver. 1.04, 2006.06.05

  -- переделана печать стека отложенных команд
  -- небольшие улучшения в коде

  ver. 1.05, 2008.08.11

  -- добавлена возможность генерирования картинок-формул с помощью mimeTeX (команда .tex)

  ver. 1.06, 2008.09.09

  -- изменена структура заголовка страницы
  -- убрана команда выдавливания сырого HTML ('!')
  -- убрана команда жесткого разрыва строки ('///')
  -- убрана специальная команда '.-'
  -- команда clear переименована в end
  -- убрана команда hline
  -- добавлена команда note
  -- добавлена поддержка нотации TeX в inline-режиме (скобки $$$...$$$)
  -- изменена семантика команды tex (теперь она генерирует outline-формулу).

  ver. 1.07, 2009.01.16

  -- добавлена поддержка ссылок на локальный документы
  -- подготовка к использованию в качестве модуля в составе утилиты генерирования дерева документации

  ver. 1.08, 2009.12.02

  -- добавлено конвертирование ссылок на lht-файлы в ссылки на htm-файлы
  -- изменен синтаксис для ссылок на локальные документы

  ver. 1.09, 2010.09.18 [r.4352]

  -- при форматировании специальных абзацев явное форматирование заменено на класс, стиль которого задан в CSS
  -- в команде code убрано использование таблиц (также используется CSS)
  -- исправлено несколько багов (неверное сообщение об ошибке при непарной команде .note, дважды закрытый тэг body)
  -- в командах .cite и .epi добавлен аргумент, позволяющий задать авторство

  ver. 1.10, 2010.09.20

  -- убрана команда .www
  -- вместо нее добавлена управляющая последовательность {{{ }}}
  -- в аргументах последовательностей {{{ }}} и [[[ ]]] поддержано задание текста ссылки

  ver. 1.11, 2010.09.20

  -- для формул добавлена поддержка картинок, внедренных в html

  ver. 1.12, 2010.09.21

  -- в специальных абзацах добавлены отступы от границы и рамки
  -- изменены цвета фона и заголовков

  ver. 1.13, 2011.06.07

  -- реализована поддржка опции '-g', генерирующей документы, предназначенные
     для публикации на google-sites.

--]=]

require "libwaki"
require "libfname"

-- умалчиваемые параметры

local dst_ext = '.htm'

local charset = 'windows-1251'
local copyleft = "automatically generated by luaht, (c) ltwood, 2004--2010"
local footer = string.format('<p><hr><center><font size=1 color=#cccccc>%s</font></center>', copyleft)

local google_site_mode = false

-- служебные функции

local line_number = 0            -- номер обрабатываемой строки

function alert( msg )   -- завершение по ошибке
  io.stderr:write(string.format('error in line %d: %s\n', line_number, msg))
  os.exit(1)
end

local outfile = nil

local function printf(fmt, ...)  -- форматный вывод строки
  return outfile:write(string.format(fmt, ...)..'\n')
end

-- base64 support for inline tex
-- http://lua-users.org/wiki/BaseSixtyFour
-- http://en.wikipedia.org/wiki/Base64
--
-- Lua 5.1+ base64 v3.0 (c) 2009 by Alex Kloss <alexthkloss@web.de>
-- licensed under the terms of the LGPL2
--
-- character table string
local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
--
-- encoding
function base64_enc( data )
    return ((data:gsub('.', function(x)
        local r,b='',x:byte()
        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
        return r;
    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if (#x < 6) then return '' end
        local c=0
        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
        return b:sub(c+1,c+1)
    end)..({ '', '==', '=' })[#data%3+1])
end
-- end of base64 support

-- mimeTeX support

local inline_tex = false
local tex_idx = 0
local tex_expr = ''

function new_tex() tex_expr = '' end
function add_tex( expr )
  if tex_expr == '' then
    tex_expr = expr
  else
    tex_expr = tex_expr .. '\n' .. expr
  end
end

local function proc_tex( expr )
  if not expr then expr = tex_expr:gsub('\n', ' ') end

  if inline_tex then
    local img_name = '.' .. os.tmpname() .. 'tmp'
    os.execute(string.format('mimetex.exe -e %s "%s"', img_name, expr))
    local file = io.open(img_name, 'rb')
    local data = base64_enc(file:read('*all'))
    file:close()
    os.remove(img_name)
    return string.format('<img src="data:image/gif;base64,%s">', data)
  else
    tex_idx = tex_idx + 1
    local img_name = string.format('mime_%04d.gif', tex_idx)
    os.execute(string.format('mimetex.exe -e %s "%s"', img_name, expr))
    return string.format('<img src="%s">', img_name)
  end
end

-- multiarg support

function parse_arg( arg, delim, def_val )
  local arg1, arg2 = arg, def_val
  local pos = arg:find(delim, 1, true)
  if pos then
    arg1 = arg:sub(1, pos-1)
    arg2 = arg:sub(pos+2, -1)
  end
  return arg1, arg2
end

-- reference support

function proc_www( arg )
  local ref, text = parse_arg(arg, '}{', '[extref]')
  return string.format('<a href="http://%s">%s</a>', ref, text)
end

local ref_tbl = {}

function proc_ref( arg )
  local ref, text = parse_arg(arg, '][', '[ref]')
  table.insert(ref_tbl, ref)
  local reft = fname.split(ref)
  if reft.ext == '.lht' then
    ref = fname.merge(reft.dir, reft.name, dst_ext)
  end
  return string.format('<a href="%s">%s</a>', ref, text)
end

-- Стек команд.
-- Содержит отложенные команды и действия, необходимые для завершения
-- текущего открытого тэга.
-- Дополнительно содержит номер строки, содержащей открывающийся тэг, и его имя.

local stack = { n = 0 }

function stack:push( nm, tg, act )
  self.n = self.n + 1
  self[self.n] = { name = nm, tag = tg, action = act, lnum = line_number }
end

function stack:pop()
  if self.n == 0 then
    alert"stack empty"
  end
  local val = self[self.n]
  self[self.n] = nil
  self.n = self.n - 1
  if val.action then
    val.action()
  end
  return val.tag
end

function stack:test()
  if self.n ~= 0 then
    for j = 1, self.n do
      io.stderr:write(string.format("note: end of <%s> (line %d) expected\n", tostring(self[j].name), self[j].lnum))
    end
    alert'command stack not empty!'
  end
end

-- обработка абзацев

local do_wait_par = true      -- ожидание начала параграфа

--[[
  По пустой строке включается режим ожидания нового абзаца (функция set_par()).
  В режиме ожидания абзаца приход строки выдавливает <p> и сбрасывает состояние
  ожидания (вызов функции test_par() в функции proc_str()).
  Так же работает команда img которая просто вставляет элементы текста.
  Некоторые команды (например заголовки) принудительно включают режим ожидания абзаца.
  Команды, выдавливающие тэг и пишущие на стек тэг-завершитель, обычно
  сбрасывают состояние ожидания абзаца (функция clear_par()).
  Команда-завершитель (cmd_end()) всегда включает состояние ожидания.
--]]

local function test_par()
  if do_wait_par then
    printf'<p>'
    do_wait_par = false
  end
end

local function set_par()
  do_wait_par = true
end

local function clear_par()
  do_wait_par = false
end

local is_code = false

-- подстановки

local function subs_symb( s )
  -- порядок замен символов имеет значение!
  s = s:gsub("%&", "&amp;")                                     -- &
  if not is_code then
    s = s:gsub("%<%<%<", "&laquo;");                            -- <<<
    s = s:gsub("%>%>%>", "&raquo;");                            -- >>>
  end
  s = s:gsub("%<", "&lt;")                                      -- <
  s = s:gsub("%>", "&gt;")                                      -- >
  if not is_code then
    s = s:gsub("%-%-%-", "&nbsp;&mdash;&nbsp;")                 -- ---
    s = s:gsub("%_%_%_(.-)%_%_%_", "<i>%1</i>")                 -- ___
    s = s:gsub("%*%*%*(.-)%*%*%*", "<b>%1</b>")                 -- ***
    s = s:gsub("%~%~%~(.-)%~%~%~", "<code>%1</code>")           -- ~~~
    s = s:gsub("%#%#%#(.-)%#%#%#", "<strike>%1</strike>")       -- ###
    s = s:gsub("%$%$%$(.-)%$%$%$", proc_tex)                    -- $$$
    s = s:gsub("%[%[%[(.-)%]%]%]", proc_ref)                    -- [[[ref]]]
    s = s:gsub("%{%{%{(.-)%}%}%}", proc_www)                    -- {{{url}}}
  end
  return s
end

-- команды

local style_tbl

local function out_styled_tag( tag, class )
  if google_site_mode then
    local style_tbl = style_tbl[tag][class]
    local style = ''
    for snm, sval in pairs(style_tbl) do
      style = style .. snm .. ': ' .. sval .. '; '
    end
    printf('<%s style="%s">', tag, style)
  else
    printf('<%s class="%s">', tag, class)
  end
end

local function cmd_hdr_templ( text, level )
  printf('<h%d>%s</h%d>', level, subs_symb(text), level)
  set_par()
end

cmd_title = function(arg) cmd_hdr_templ(arg, 1) end
cmd_sect  = function(arg) cmd_hdr_templ(arg, 2) end
cmd_subs  = function(arg) cmd_hdr_templ(arg, 3) end
cmd_para  = function(arg) cmd_hdr_templ(arg, 4) end

function cmd_enum()
  printf'<ol>'
  clear_par()
  stack:push('enum', '</ol>')
end

function cmd_list()
  printf'<ul>'
  clear_par()
  stack:push('list', '</ul>')
end

function cmd_item()
  printf'<li>'
  clear_par()
end

function cmd_defl()
  printf'<dl>'
  clear_par()
  stack:push('defl', '</dl>')
end

function cmd_def( term )
  printf('<dt>%s', subs_symb(term))
  printf'<dd>'
  clear_par()
end

function cmd_note()
  out_styled_tag('blockquote', 'note')
  clear_par()
  stack:push('note', '</blockquote>')
end

function cmd_cite( author )
  out_styled_tag('blockquote', 'cite')
  clear_par()
  if author then
    stack:push('cite', '<br>//&nbsp;' .. author .. '</blockquote>')
  else
    stack:push('cite', '</blockquote>')
  end
end

function cmd_sic()
  out_styled_tag('blockquote', 'sic')
  clear_par()
  stack:push('sic', '</blockquote>')
end

function cmd_epi( author )
  out_styled_tag('blockquote', 'epi')
  clear_par()
  if author then
    stack:push('epi', '<br>//&nbsp;' .. author .. '</blockquote>')
  else
    stack:push('epi', '</blockquote>')
  end
end

function cmd_code()
  out_styled_tag('pre', 'code')
  clear_par()
  is_code = true;
  stack:push('code', '</pre>', function() is_code = false end)
end

function cmd_img( file )
  test_par()
  printf('<img src="%s">', file)
end

function cmd_fig( file )
  printf('<p><center><img src="%s"></center>', file)
  printf'<center><b><i>'
  clear_par()
  stack:push('fig', '</i></b></center>')
end

function cmd_end()
  local fin = stack:pop()
  if fin and fin ~= '' then
    printf("%s", fin)
  end
  set_par()
end

function cmd_tex()
  clear_par()
  is_tex = true;
  new_tex()
  stack:push('tex', '', function() printf("<p>%s", proc_tex()); is_tex = false end)
end

-- Обработка команды.
-- К имени команды слева добавляется префикс 'cmd_'
-- и производится попытка вызова полученной команды.
-- При неудаче справа добавляются скобки и попытка повторяется.

local function proc_cmd( cmdl )
  if cmdl:match("^%.%s*$") then
    cmd_end()
    return
  end

  -- добавляем префикс и удваиваем символы '\'
  cmdl = "cmd_" .. cmdl:gsub('\\', '\\\\')
  local cmd = loadstring(cmdl)
  if cmd then
    cmd()
  else
    cmd = loadstring(cmdl .. "()")
    if cmd then
      cmd()
    else
      alert("can't call command <" .. cmdl .. ">")
    end
  end
end

-- обработка регулярных строк

local function proc_str( str )
  test_par()
  printf("%s", subs_symb(str))
end

local function proc_empty_str()
  set_par()
end

-- логика разбора 'сырой' строки

-- Внутри .code остановка происходит только по '..' в первой позиции
-- а команды игнорируются, но производится замена символов.
-- В нормальном тексте обрабатываются обычные строки, пустые строки,
-- команды, комментарии и todo-комментарии.
-- Команда следует после точки, которая сама не входит в команду.

local function proc_line( line )
  -- специальная обработка внутри .code
  if is_code then
    if line:sub(1, 2) == '..' then
      cmd_end()
    else
      printf("%s", subs_symb(line))
    end
    return
  end

  -- специальная обработка внутри .tex
  if is_tex then
    if line:sub(1, 2) == '..' then
      cmd_end()
    else
      add_tex(line)
    end
    return
  end

  -- нормальный текст
  line = line:match("^%s*(.*)$") -- пропускаем ведущие пробелы
  if line == "" then
    proc_empty_str()            -- отдельно обрабатываем пустые строки
  else
    local ch = line:sub(1, 1)
    if ch == "." then           -- по точке обрабатываем команду
      proc_cmd(line:sub(2))
    elseif ch == "#" then       -- пропускаем комментарии
      -- но печатаем строки todo-комментариев
      if line:sub(2, 2) == "!" then
        io.stderr:write(waki.recode(line, 'wa') .. '\n')
      end
    else                        -- выводим регулярные строки
      proc_str(line)
    end
  end
end

-- заголовки и трэйлеры

style_tbl = {
  ['blockquote'] = {
    ['sic'] = {
      ['background-color'] = '#dddddd',
      ['border'] = '1px dashed #aaaaaa',
      ['padding'] = '3px',
      ['font-weight'] = 'bold',
      ['font-size'] = '90%',
      ['line-height'] = '120%',
    },
    ['note'] = {
      ['background-color'] = '#dddddd',
      ['border'] = '1px dashed #aaaaaa',
      ['padding'] = '3px',
      ['font-size'] = '90%',
      ['line-height'] = '120%',
    },
    ['cite'] = {
      ['background-color'] = '#dddddd',
      ['border'] = '1px dashed #aaaaaa',
      ['padding'] = '3px',
      ['font-style'] = 'italic',
      ['font-size'] = '90%',
      ['line-height'] = '120%',
    },
    ['epi'] = {
      ['margin-left'] = '50%',
      ['margin-right'] = '0%',
      ['border'] = '1px dashed #aaaaaa',
      ['padding'] = '3px',
      ['background-color'] = '#dddddd',
      ['font-style'] = 'italic',
      ['font-weight'] = 'bold',
      ['font-size'] = '90%',
      ['line-height'] = '120%',
    },
  },
  ['pre'] = {
    ['code'] = {
      ['background-color'] = '#dddddd',
      ['border'] = '1px dashed #aaaaaa',
      ['padding'] = '3px',
      ['font-size'] = '90%',
      ['line-height'] = '120%',
    },
  },
}

local style = [[
  body {
    background-color: #e7e9dc;
    font-family: arial;
    margin-left: 3%; margin-right: 3%;
    text-align: justify;
    line-height: 125%;
  }
  h1 { color: #4e4f43; }
  h2 { color: #4e4f43; }
  h3 { color: #4e4f43; }
  h4 { color: #4e4f43; }
  code {
    font-size: 100%;
  }
]]

local function print_header( fn )
  local id = fn .. '-' .. os.date('%Y.%m.%d-%H:%M:%S')
  printf'<html>'
  printf'<!-- automatically generated by luaht, (c) ltwood, 2004--2010 -->'
  printf'<head>'
  printf('<meta http-equiv="Content-Type" content="text/html; charset=%s">', charset)
  printf('<title>%s</title>', id)
  printf'</head>'

  printf('<style type="text/css">')
  printf('%s', style)
  for tnm, tst_tbl in pairs(style_tbl) do
    for cnm, cst_tbl in pairs(tst_tbl) do
      printf('  %s.%s {', tnm, cnm)
      for snm, sval in pairs(cst_tbl) do
        printf('    %s: %s;', snm, sval)
      end
      printf('  }')
    end
  end
  printf('</style>', style)

  printf('<body>')
end

local function print_footer()
  printf("%s", footer)
  printf'</body>'
  printf'</html>'
end

-- генерирование гипертекста

local function generate_html( src, inline )
  inline_tex = inline
  local fnt = fname.split(src)
  local dst = fname.merge(fnt.dir, fnt.name, dst_ext)

  ref_tbl = {}
  outfile = assert(io.open(dst, "wt"))
  if not google_site_mode then
    print_header(src)
  end
  line_number = 1
  for s in io.lines(src) do
    proc_line(s)
    line_number = line_number + 1
  end
  if not google_site_mode then
    print_footer()
  end
  stack:test()
  return ref_tbl
end

luaht = {
  proc = generate_html
}

-- main

if not package.loaded['luaht'] then
  require "libcmdl"
  local opt = cmdl.options()

  -- должен быть один аргумент - имя файла
  if #arg ~= 1 then
    io.stderr:write("html generator, ver 1.13, (c) ltwood\n")
    io.stderr:write("usage: luaht [-i] [-g] lht-file-name\n")
    os.exit(1)
  end
  if opt['-g'] then
    google_site_mode = true
  end
  generate_html(arg[1], opt['-i'])
else
  return luaht
end
