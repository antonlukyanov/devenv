.title "Как работает llake"

.sect "Старт llake"

При старте ~~~llake~~~ извлекает из командной строки имя действия
(~~~pdep~~~, ~~~make~~~, ~~~build~~~, ~~~export~~~)
и имя конфигурационного файла.
Затем ~~~llake~~~ последовательно выполняет следующие действия:

.enum
.item
Код из конфигурационного  файла выполняется в защищенном окружении и из него извлекается
таблица параметров с именем ~~~lake~~~.
.item
Путь к директории запуска конвертируется в относительный путь,
заданный относительно директории ~~~lake.basedir~~~, и сохраняется.
.item
Если присутствует функция ~~~lake.prepare()~~~, то она выполняется.
.item
Строится справочник репозитория исходников.
.item
Строится дерево зависимостей.
.item
В зависимости от имени действия выполняется печать списка зависимостей, сборка проекта, либо его экспорт.
..

Действия ~~~make~~~ и ~~~build~~~ являются вариантами единой процедуры сборки проекта.

.sect "Обработка путей"

Все пути внутри ~~~llake~~~ указываются относительно базовой директории репозитория.
Полный путь к этой директории извлекается из переменной ~~~lake.basedir~~~.

Все пути, получаемые из конфигурационного файла, приводятся к единому виду.
Это подразумевает наличие слэша в конце пути и использование единого разделителя элементов пути.

Флаг ~~~lake.rev_slash~~~ включает использование обратной косой черты в качестве разделителя
вместо прямой косой черты (по умолчанию).

Флаг ~~~lake.case_sens~~~ переводит обработку путей в режим чувствительности к регистру
(по умолчанию все пути приводятся к нижнему рагистру).

.sect "Справочник репозитория исходников"

Основное назначение справочника --- поиск файла в репозитории по его имени (без явно указанного пути).
Справочник кэширует информацию о найденных и отсутствующих файлах и проверяет единственность
имени файла в пределах своего списка директорий поиска.

.subs "Построение справочника"

Построение справочника происходит следующим образом:

.enum
.item
Инициализируется список директорий для поиска файлов.
.item
В зависимости от значения флага ~~~lake.use_cwd~~~ стартовая директория добавляется или не добавляется
в список директорий поиска.
.item
Все директории из списка ~~~lake.use~~~ добавляются в список директорий поиска.
..

.subs "Обработка use-файла"

Если присутствует строковый параметр ~~~llake.usefile_name~~~, то для каждой директории
производится обработка use-файла:

.enum
.item
Проверяется наличие файла с именем ~~~llake.usefile_name~~~ в заданной директории.
.item
При наличии файла он выполняется в защищенном окружении и из него извлекается
таблица директорий с именем ~~~use~~~.
.item
Все директории из этой таблицы добавляются в список директорий поиска
(при этом для них также производится обработка use-файлов).
..

При обработке use-файлов корректно обрабатываются циклические ссылки
(ссылка из use-файла директории ~~~A~~~ на директорию ~~~B~~~, в которой содержится
use-файл, ссылающийся на директорию ~~~A~~~).

.subs "Обработка исходного файла"

Найденный в репозитории исходный файл обрабатывается --- по нему строится список зависимостей
и список задач (модулей, подлежащих сборке).

Построением списка зависимостей по исходному файлу занимается функция ~~~lake[file_ext].dep_parser()~~~,
а построением списка подлежащих сборке модулей --- функция ~~~lake[file_ext].task_parser()~~~.

Каждая из этих функций (если она задана) автоматически вызывается для каждой строки исходного файла.
Если такая функция возвращает значение ~~~nil~~~, то обработка исходного файла прерывается.
В противном случае функция может вернуть строку или таблицу строк
(отсутствие зависимости или задачи соответствует пустой таблице).
Каждая возвращенная строка добавляется к соответствующему списку.

.sect "Дерево зависимостей"

Дерево зависимостей управляет как самими зависимостями между файлами, так и списком модулей,
подлежащих линковке (задачи).

Построение дерева зависимостей производится путем добавления в него стартового файла,
имя которого извлекается из переменной ~~~lake.start~~~.
При добавлении каждого файла для него производятся следующие операции:

.enum
.item
  Сам файл добавляется в глобальный список задач.
.item
  Для файла получается список зависимостей и список задач.
.item
  Все задачи добавляются в глобальный список задач.
.item
  Список зависимостей рекурсивно разворачивается до
  полного списка зависимостей, включая косвенные зависимости
  (когда файл ~~~A~~~ зависит от файла ~~~B~~~,  который сам зависит от файла ~~~C~~~).
.item
  Для каждого файла-зависимости получается список задач и все они добавляются в глобальный список задач.
.item
  Для каждого файла-зависимости вызывается (если она присутствует) функция ~~~lake[file_ext].dep2src()~~~ и
  если она возвращает не ~~~nil~~~, то возвращаемое имя файла (задача, соответствующая файлу-зависимости)
  добавляется в список задач, причем если присутствует и взведен флаг ~~~lake[file_ext].do_demand_src~~~,
  то задача добавляется безусловно, а если нет, то только при наличии соответствующего задаче файла.
..

При рекурсивном разворачивании списка зависимостей рекурсивный спуск (т.е. включение в полный список зависимостей
всех косвенных зависимостей) не производится, если присутствует и взведен фгаг ~~~lake[file_ext].is_nontransitive_dep~~~.

.sect "Сборка проекта"

Сборка проекта производится при выполнении действий ~~~make~~~ и ~~~build~~~,
которые отличаются друг от друга только тем, что при выполнении действия ~~~build~~~
все результирующие файлы задач и конечный результирующий файл всегда считаются устаревшими.

При сборке проекта производятся следующие действия:

.enum
.item
  Последовательная обработка каждой задачи (компиляция всех модулей).
.item
  Совместная обработка всех задач (линковка модулей).
..

.subs "Последовательная обработка задач"

При последовательной обработке задач для каждой задачи выполняются следующие действия:

.enum
.item
  Выполняется функция ~~~lake[file_ext].src2obj()~~~, которая по имени задачи и по пути к ней
  генерирует полное имя файла, получаемого при ее обработке (обычно это имя объектного файла).
  Дополнительно этой функции передается базовая директория репозитория.
.item
  Полное имя результирующего файла добавляется к списку всех результирующих файлов.
.item
  Результирующему файлу присваивается вес, который извлекается из переменной ~~~lake[file_ext].weight~~~.
  Если переменная отсутствует, то задаче присваивается нулевой вес.
.item
  Строится список полных путей ко всем файлам-зависимостям данной задачи.
.item
  Если для задачи присутствует поле ~~~lake[file_ext].compile()~~~ и результирующий файл устарел,
  либо если выполняемое действие подразумевает полную пересборку проекта, то вызывается функция
  ~~~lake[file_ext].compile()~~~, которая возвращает командную строку и экранное сообщение.
  Командная строка выполняется, а экранное сообщение выводится на экран.
..

Если для файла-задачи отсутствует поле ~~~lake[file_ext].compile()~~~, то считается,
что результирующий файл задачи всегда существует и актуален (например, он может совпадать
с исходным файлом задачи, что имеет место для библиотек).

Проверка того, что результирующий файл задачи устарел, состоит в следующем:

.enum
.item
  Если результирующий файл задачи отсутствует, то он считается устаревшим.
.item
  Если исходный файл-задача имеет дату модификации более позднюю, чем
  существующий результирующий файл задачи, то результирующий файл считается устаревшим.
.item
  Если исходный файл-задача зависит от файлов-зависимостей, имеющих дату модификации более позднюю,
  чем существующий результирующий файл задачи, то результирующий файл считается устаревшим.
..

.subs "Совместная обработка задач"

Совместная обработка задач состоит в следующем:

.enum
.item
  Список всех результирующих файлов сортируется в порядке возрастания веса.
.item
  Имя конечного результирующего файла извлекается из переменной ~~~lake.dest~~~.
.item
  Если конечный результирующий файл устарел, либо если выполняемое действие подразумевает полную пересборку проекта,
  то вызывается функция ~~~lake.link()~~~, которая возвращает командную строку и экранное сообщение.
  Командная строка выполняется, а экранное сообщение выводится на экран.
.item
  Если при запуске была указана опция ~~~'-s'~~~ и присутствует параметр ~~~lake.strip~~~,
  то вызывается функция ~~~lake.strip()~~~,
  которая возвращает командную строку и экранное сообщение.
  Командная строка выполняется, а экранное сообщение выводится на экран.
  Это действие производится даже в том случае, когда конечный результирующий файл не требует сборки.
..

Проверка того, что конечный результирующий файл задачи устарел, состоит в следующем:

.enum
.item
  Если конечный результирующий файл задачи отсутствует, то он считается устаревшим.
.item
  Если один из результирующих файлов задач имеет дату модификации более позднюю,
  чем существующий конечный результирующий файл, то конечный результирующий файл считается устаревшим.
..

.sect "Экспорт проекта"

Экспорт проекта происходит следующим образом:

.enum
.item
  В текущей директории создается директория с именем ~~~'export'~~~  и в нее копируются исходные файлы
  для всех задач.
.item
  В директории ~~~'./export'~~~ создается файл ~~~makefile~~~ для сборки проекта на стороне заказчика
  с помощью стандартной утилиты ~~~make~~~.
..

Создание файла ~~~makefile~~~ производится следующим образом:

.enum
.item
  В генерируемый ~~~makefile~~~ последовательно записываются все строки из таблицы ~~~export_preambule~~~.
.item
  Для каждой задачи генерируется имя соответствующего результирующего файла путем вызова функции
  ~~~lake[file_ext].export_src2obj()~~~ и все имена результирующих файлов помещаются в таблицу и
  сортируются в порядке возрастания веса.
.item
  Строится правило для конечного результирующего файла.
  В списке зависимостей перечисляются все результирующие файлы, соответствующие задачам.
  В списке действий на первом месте идет команда, возвращаемая функцией ~~~lake.export_link()~~~,
  затем идет команда, возвращаемая функцией ~~~lake.strip()~~~.
  Если параметр ~~~lake.export_link~~~ отсутствует, то вместо функции ~~~lake.export_link()~~~
  вызывается функция ~~~lake.link()~~~.
.item
  Для каждой задачи строится правило для ее результирующего файла.
  В списке зависимостей первым идет исходный файл задачи, затем
  перечисляются все зависимости для данной задачи.
  Если для задачи присутствует параметр ~~~lake[file_ext].export_compile()~~~,
  то далее указывается команда, возвращаемая функцией ~~~lake[file_ext].export_compile()~~~.
  В противном случае если для задачи присутствует параметр ~~~lake[file_ext].compile()~~~,
  то указывается команда, возвращаемая функцией ~~~lake[file_ext].compile()~~~.
..

.sect "Список параметров"

.subs "Глобальные параметры"

.defl
.def "~~~lake.basedir~~~"
  Путь к корневой директории репозитория.

.def "~~~lake.prepare( basedir, proj_dir )~~~"
  Функция, вызываемая до первого обращения к репозиторию.
  В аргументе ~~~basedir~~~ передается полный путь к базовой директории репозитория,
  а в аргументе ~~~proj_dir~~~ передается путь к текущему проекту.
  Необязательный параметр, по умолчанию никаких подготовительных действий не производится.

.def "~~~lake.rev_slash~~~"
  Флаг, включающий использование обратного слэша.
  Необязательный параметр, по умолчанию используется прямой слэш.

.def "~~~lake.case_sens~~~"
  Флаг, включающий регистровую чувствительность в именах файлов.
  Необязательный параметр, по умолчанию регистровая чувствительность отключена.

.def "~~~lake.use_cwd~~~"
  Флаг, включающий текущую директорию в список директорий поиска файлов.
  Необязательный параметр, по умолчанию текущая директория не входит в число директорий поиска.

.def "~~~lake.use~~~"
  Список путей поиска файлов.
  Обязательный параметр, но список может быть пустым.

.def "~~~llake.usefile_name~~~"
  Имя use-файла.
  Необязательный параметр, по умолчанию не производится обработка use-файла.

.def "~~~lake.start~~~"
  Имя стартового файла для сборки приложения.

.def "lake.dest"
  Имя конечного результирующего файла.

.def "~~~lake.link( dst, obj_list )~~~"
  Функция, генерирующая командную строку для сборки конечного результирующего файла.
  В аргументах передается имя конечного результирующего файла (~~~dst~~~)
  и таблица, содержащая полные имена всех результирующих файлов.
  Функция возвращает командную строку, применяемую для сборки конечного результирующего файла.
  Также функция возвращает экранное сообщение, выводимое перед выполнением командной строки.

.def "~~~lake.export_link( dst, obj_list )~~~"
  Функция, генерирующая командную строку для сборки конечного результирующего файла в экспортном ~~~makefile~~~.
  В аргументах передается имя конечного результирующего файла (~~~dst~~~)
  и таблица, содержащая полные имена всех результирующих файлов.
  Функция возвращает командную строку, применяемую для сборки конечного результирующего файла.

.def "~~~lake.strip( dst )~~~"
  Функция, генерирующая командную строку для постобработки конечного результирующего файла.
  В аргументах передается имя конечного результирующего файла (~~~dst~~~).
  Функция возвращает командную строку, применяемую для постобработки конечного результирующего файла.
  Также функция возвращает экранное сообщение, выводимое перед выполнением командной строки.
  Необязательный параметр, в случае отсутствия постобработка не производится.

.def "~~~lake.lib2fname()~~~"
  Функция, преобразующая имя библиотеки в имя соответствующего файла.
  Вызывается из функции ~~~cc.lib_parser()~~~ и может отсутствовать, если
  конфигурационный файл не использует эту функцию.

.def "~~~lake.res2fname()~~~"
  Функция, преобразующая имя коллекции ресурсов в имя соответствующего файла.
  Вызывается из функции ~~~cc.lib_parser()~~~ и может отсутствовать, если
  конфигурационный файл не использует эту функцию.

.def "~~~export_preambule~~~"
  Таблица, состоящая из строк, записываемых в преамбулу генерируемого ~~~makefile~~~.
..

.subs "Параметры, связанные с расширением"

Для каждого расширения, участвующего в сборке, таблица ~~~lake~~~ содержит соответствующую подтаблицу,
проиндексированную этим расширением (далее ~~~file_ext~~~).

.defl
.def "~~~lake[file_ext].dep_parser( s )~~~"
  Функция, строящая список зависимостей по исходному файлу.
  Последовательно вызывается для всех строк (строка передается ей как аргумент)
  и для каждой строки возвращает строку или таблицу строк с именами файлов-зависимостей.
  Необязательный параметр, по умолчанию разбора файла не производится.

.def "~~~lake[file_ext].task_parser( s )~~~"
  Функция, строящая список подлежащих сборке модулей по исходному файлу.
  Последовательно вызывается для всех строк (строка передается ей как аргумент)
  и для каждой строки возвращает строку или таблицу строк с именами файлов-задач.
  Необязательный параметр, по умолчанию разбора файла не производится.

.def "~~~lake[file_ext].dep2src( fn )~~~"
  Функция, возвращающая имя файла, сборка которого необходима при наличии данной зависимости.
  аргументе передается имя файла-зависимости.
  Если функция решает, что для данной зависимости задачу добавлять не нужно, то она может вернуть значение ~~~nil~~~.
  Необязательный параметр, по умолчанию для зависимости не добавляется никакой задачи.

.def "~~~lake[file_ext].do_demand_src~~~"
  Флаг, управляющий добавлением задачи, соответствующей данной зависимости.
  Если этот флаг отсутствует или принимает значение ~~~false~~~, то добавление задачи
  производится только при наличии соответствующего файла.

.def "~~~lake[file_ext].is_nontransitive_dep~~~"
  Не включать в полный список зависимостей косвенные зависимости.
  Необязательный параметр, по умолчанию производится включение всех косвенных зависимостей.

.def "~~~lake[file_ext].export_src2obj( tname )~~~"
  Функция, которая по имени задачи (~~~tname~~~, без расширения)
  генерирует имя файла, получаемого при ее обработке в экспортном ~~~makefile~~~
  (обычно это просто имя объектного файла).

.def "~~~lake[file_ext].src2obj( bp, tdir, tname )~~~"
  Функция, которая по имени задачи (~~~tname~~~, без расширения), пути к ней (~~~tdir~~~) и
  пути к базовой директории репозитория (~~~bp~~~)
  генерирует полное имя файла, получаемого при ее обработке (обычно это имя объектного файла).

.def "~~~lake[file_ext].weight~~~"
  Вес, присваиваемый задаче.
  Необязательный параметр, по умолчанию присваивается нулевой вес.

.def "~~~lake[file_ext].compile( dst, src_name, src_dir, paths )~~~"
  Функция, генерирующая командную строку для обработки файла-задачи.
  В аргументах передается имя результирующего файла задачи (~~~dst~~~),
  имя исходного файла задачи (~~~src_name~~~),
  директирия исходного файла задачи (~~~src_dir~~~)
  и таблица, содержащая полные пути ко всем файлам-зависимостям данной задачи (~~~paths~~~).
  Функция возвращает командную строку, применяемую для обработки исходного файла задачи
  и создания результирующего файла.
  Также функция возвращает экранное сообщение, выводимое перед выполнением командной строки.
  Необязательный параметр, по умолчанию не выполняется никаких команд по генерированию результирующего файла.

.def "~~~lake[file_ext].export_compile( dst, src_name )~~~"
  Функция, генерирующая командную строку для обработки файла-задачи в экспортном ~~~makefile~~~.
  В аргументах передается имя результирующего файла задачи (~~~dst~~~) и имя исходного файла задачи (~~~src_name~~~).
  Функция возвращает командную строку, применяемую для обработки исходного файла задачи
  и создания результирующего файла.
  Необязательный параметр, по умолчанию не выполняется никаких команд по генерированию результирующего файла.
..

.sect "Защищенные окружения"

.subs "Общие функции и таблицы"

Файл конфигурации и use-файлы выполняются в защищенном окружении, из которого доступны
следующие функции и таблицы:

.enum
.item
  Стандартные функции ~~~type()~~~, ~~~tostring()~~~, ~~~tonumber()~~~,
  ~~~print()~~~, ~~~error()~~~, ~~~assert()~~~, ~~~pairs()~~~, ~~~ipairs()~~~.
.item
  Стандартные библиотеки ~~~table~~~, ~~~string~~~, ~~~io~~~, ~~~os~~~.
..

.subs "Окружение конфигурационного файла"

В защищенном окружении конфигурационного файла дополнительно доступны следующие функции и таблицы:

.enum
.item
  Таблица ~~~lake~~~, в которую конфигурационный файл помещает параметры, экспортируемые в ~~~llake~~~.
.item
  Таблица ~~~cc~~~, содержащая функции-помощники.
.item
  Вспомогательные функции ~~~abort()~~~, ~~~run()~~~, ~~~subst()~~~, ~~~split()~~~,
  экспортируемые утилитой ~~~llake~~~.
.item
  Функции ~~~addpar()~~~ и ~~~use_rules()~~~ также экспортируемые библиотекой ~~~liblake~~~
  и предназначенные для поддержки т.н. файлов правил.
..

.subs "Функции помощники"

Функции помощники являются элементами таблицы ~~~cc~~~ и предназначены для упрощения задачи
написания правил для языков ~~~C/C++~~~.
Они предоставляют возможность выделения управляющих комментариев и директив включения файлов-заголовков.

.defl

.def "~~~cc.hdr_parser( s )~~~"
  Парсер строки для файла-заголовка.
  Проверяет строку ~~~s~~~ на ее соответствие шаблону управляющего комментария
  <<<конец области разбора>>> вида ~~~'/*#lake:stop*/'~~~ и в этом случае возвращает ~~~nil~~~.
  Проверяет строку ~~~s~~~ на ее соответствие шаблону <<<включение файла-заголовка>>>
  вида ~~~'#include "filename"'~~~.
  Если строка удовлетворяет шаблону, то возвращает имя файла-заголовка,
  иначе --- пустую таблицу.

.def "~~~cc.lib_parser()~~~"
  Парсер строки для файла с исходным кодом.
  Проверяет строку ~~~s~~~ на ее соответствие шаблону управляющего комментария
  <<<конец области разбора>>> вида ~~~'/*#lake:stop*/'~~~ и в этом случае возвращает ~~~nil~~~.
  Проверяет строку ~~~s~~~ на ее соответствие шаблону управляющего комментария
  <<<линковка с библиотекой>>> вида ~~~'/*#lake:lib:filename*/'~~~.
  Если строка удовлетворяет шаблону, то вызывает функцию ~~~lake.lib2fname()~~~,
  и возвращает возвращаемое этой функцией имя файла библиотеки.
  Проверяет строку ~~~s~~~ на ее соответствие шаблону управляющего комментария
  <<<файл ресурсов>>> вида ~~~'/*#lake:res:filename*/'~~~.
  Если строка удовлетворяет шаблону, то вызывает функцию ~~~lake.res2fname()~~~,
  и возвращает возвращаемое этой функцией имя файла библиотеки.
  В противном случае возвращает пустую таблицу.

..

Таким образом, при использовании функций-помощников происходит автоматическая обработка
следующих управляющих комментариев:

.code
  /*#lake:stop*/
  /*#lake:lib:filename*/
..

При достижении управляющего комментария ~~~/*#lake:stop*/~~~ функции разбора строк прекращают работу.
Последовательное использование управляющего комментария <<<конец области разбора>>>
позволяет существенно ускорить процесс построения дерева зависимостей.

.subs "Вспомогательные функции"

.defl
.def "~~~abort( msg )~~~"
  Прекращает выполнение скрипта ~~~llake~~~ и выводит сообщение ~~~msg~~~.

.def "~~~run( cmd, msg )~~~"
  Выполняет команду ~~~cmd~~~ и выводит сообщение ~~~msg~~~.
  В зависимости от опций, с которыми был запущен скрипт ~~~llake~~~,
  функция может не выполнить команду ~~~cmd~~~, а только вывести сообщение,
  а также напечатать саму выполняемую команду вместо сообщения ~~~msg~~~.

.def "~~~subst( s, t )~~~"
  Выполняет в строке ~~~s~~~ рекурсивную замену подстрок вида ~~~${macro}~~~
  на элементы ~~~t[macro]~~~ таблицы ~~~t~~~.

.def "~~~split( fn )~~~"
  Разбирает полное имя файла на путь, имя и расширение и
  возвращает таблицу с полями dir, name и ext.
  Точка включается в расширение, путь всегда завершается слэшем.
  Функция корректно обрабатывает пути как с прямыми, так и с обратными слэшами.

..

.subs "Поддержка файлов правил"

Поскольку ~~~llake~~~ требует присутствия в конфигурационном файле значительного количества параметров,
то представляется неудобным задавать все параметры в конфигурационном файле каждого приложения.
Вместо этого полезно иметь общий конфигурационный файл (т.н. файл правил), экспортирующий большую часть параметров,
а в конфигурационном файле приложения указывать лишь некоторые параметры, значения которых часто меняются.
Утилита ~~~llake~~~ экспортирует некоторые переменные и функции, облегчающие создание
общеупотребительных файлов правил.

.defl

.def "~~~lake~~~"
  Пустая таблица, экспортируемая утилитой ~~~llake~~~ в пространство имен конфигурационного файла.
  Как правило файлы правил и конфигурационные файлы приложений не создают собственную таблицу ~~~lake~~~,
  а лишь добавляют новые параметры в предоставленную им таблицу.

.def "~~~addpar( t )~~~"
  Эта функция принимает в аргументе таблицу и копирует все ее поля в таблицу ~~~lake~~~.
  Значения параметров, уже присутствующие в таблице ~~~lake~~~, заменяются на новые.

.def "~~~use_rules( rules_fn, rules_mode )~~~"
  Эта функция активирует файл правил.
  Путь ~~~rules_fn~~~ к файлу правил указывается относительно базовой директории.
  Если файл правил экспортирует функцию ~~~init_rules()~~~, то она выполняется с аргументом ~~~rules_mode~~~
  (если этот аргумент не был указан, то в ~~~init_rules()~~~ передается пустая таблица).
..

Выполнение функции ~~~use_rules( rules_fn, rules_mode )~~~ состоит в следующем:
.enum
  .item
    Путь к базовой директории вычисляется и присваивается
    глобальной переменной ~~~basedir~~~ (но не полю таблицы ~~~lake~~~!).
  .item
    По пути ~~~basedir~~~ выполняется файл с именем ~~~rules_fn~~~ (имя файла правил также может содержать путь).
  .item
    Если после выполнения файла ~~~rules_fn~~~ в глобальной области видимости появилась
    функция ~~~init_rules()~~~, то эта функция выполняется, причем в качестве аргумента
    ей передается либо таблица ~~~rules_mode~~~, либо пустая таблица
    (если таблица ~~~rules_mode~~~ не была передана).
..

Вычисление пути к базовой директории производится путем подъема по файловой системе
вплоть до директории, содержащей элемент с именем ~~~'lake_marker'~~~.
Это может быть файл произвольного содержания или директория.

После выполнения функции ~~~use_rules()~~~ в глобальной области видимости конфигурационного файла
появляется переменная ~~~basedir~~~ со значением пути к базовой директории.
Файл правил может (но не должен) поместить значение глобальной переменной ~~~basedir~~~
в одноименное поле таблицы ~~~lake~~~.

.sect "Опции командной строки"

Кроме действия и мени файла в командной строке могут быть заданы опции, модифицирующие поведение ~~~llake~~~.

.defl

.def "***-v***, vesbose mode"
  В этом режиме вместо сообщений, возвращаемых функциями ~~~compile()~~~, ~~~link()~~~ и ~~~strip()~~~
  на экран выводятся реально выполняемые командные строки.

.def "***-d***, dry run"
  В этом режиме все команды сборки выводятся на экран, но не выполняются.
  Поскольку при этом не происходит обновление объектников, то команда сборки конечного
  результирующего файла будет выведена только в том случае, когда один из объектников
  был модифицирован при другой сборке (возможно при сборке другого приложения).

.def "***-s***, strip executable"
  Произвести постобработку конечного результирующего файла.
  Постобработка будет произведена вне зависимости от того, производилась
  ли сборка конечного результирующего файла.
  При экспорте проекта команда постобработки выводится в ~~~makefile~~~ вне зависимости
  от того, указана ли данная опция.

..

.sect "Известные проблемы"

.list

.item
  При старте ~~~llake~~~ проверяет, что директория проекта является поддиректорией базовой директории
  репозитория и превращает полный путь к директории проекта в относительный.
  При этом проверка осуществляется путем посимвольного сравнения имен директорий (после их приведения
  к нормализованному виду в соответствии с параметрами ~~~rev_slash~~~ и ~~~case_sens~~~).
  Поэтому путь, получаемый из переменной ~~~lake.basedir~~~ должен (с точностью до типа слэшей и, возможно,
  регистра букв) иметь тот же вид, что и путь, печатаемый командой ~~~pwd~~~.

.item
  В режиме dry run (опция ~~~'-d'~~~) не происходит обновление объектников, поэтому команда
  сборки конечного результирующего файла будет выведена только в том случае, когда один из объектников
  был модифицирован при другой сборке (возможно при сборке другого приложения).

..
