--[[
  ‘ормирует исходник класса, содержащего статические данные 
  из заданного бинарного файла
--]]

if #arg ~= 2 then
  io.write('Usage: lua mkbinchunk.lua bin-file-name out-file-base-name\n')
  os.exit()
end

function write_bin( file, data )
  file:write('  ')
  for j = 1, #data do
    local code = data:byte(j)
    file:write(string.format("0x%02X, ", code))
    if math.fmod(j, 16) == 0 then
      file:write('\n  ')
    end
  end
  if math.fmod(#data, 16) ~= 0 then
    file:write('\n')
  end
end

--[[
function write_chunk( file, name, data )
  file:write('static const char luacc_' .. name .. '[] = {\n')
  write_bin(c_file, data)
  c_file:write('};\n\n');
end
--]]

-- main

local data_file = assert(io.open(arg[1], 'rb'))
local data = data_file:read('*all')
data_file:close()

name = arg[2]

c_file = assert(io.open(name .. '.cc', 'wt'))
c_file:write('// This file is automatically generated -- do not edit!\n\n')
c_file:write(string.format('#include "%s"\n\n', name .. '.h'))
c_file:write(string.format("const int %s::len = %d;\n", name, #data))
c_file:write(string.format("const char %s::data[] = {\n", name))
write_bin(c_file, data)
c_file:write(string.format("};\n", name))

h_file = assert(io.open(name .. '.h', 'wt'))
h_file:write('// This file is automatically generated -- do not edit!\n\n')
h_file:write(string.format('#ifndef _%s_H_\n', name:upper()))
h_file:write(string.format('#define _%s_H_\n\n', name:upper()))
h_file:write(string.format("class %s {\n", name))
h_file:write(string.format("public:\n"))
h_file:write(string.format("  static const char data[];\n"))
h_file:write(string.format("  static const int len;\n"))
h_file:write(string.format("};\n\n"))
h_file:write(string.format('#endif // _%s_H_\n', name:upper()))
