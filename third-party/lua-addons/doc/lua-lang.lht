.title "Язык программирования Lua"

.epi "Roberto Ierusalimsky"
 Lua gives you the power; you build the mechanisms.
..

.sect "Введение"

~~~Lua~~~ --- язык программирования, предназначенный для встраивания
в другие приложения чтобы дать их пользователям возможность писать
конфигурационные скрипты и высокоуровневые сценарии.
~~~Lua~~~ поддерживает процедурный, объектный и функциональный
стили программирования, но является в то же время простым языком.
Интерпретатор ~~~Lua~~~ написан на ~~~ANSI-C~~~ и представляет
собой библиотеку, которую можно подключить к любой программе.
В этом случае управляющая программа может вызвать библиотечные функции
для выполнения участка кода на ~~~Lua~~~ и работы с данными,
определенными в этом коде.
Также управляющая программа может регистрировать собственные функции
таким образом, что их можно будет вызывать из кода на ~~~Lua~~~.
Последняя возможность позволяет использовать ~~~Lua~~~ как язык,
который можно адаптировать к произвольной области применения.
Другое применение ~~~Lua~~~ --- написание простых независимых скриптов.
Для этой цели имеется простой интерпретатор ~~~Lua~~~,
использующая эту библиотеку для выполнения кода, вводимого с консоли или из файла.

.sect "Лексические соглашения"

Идентификаторы могут содержать буквы, цифры и символы подчеркивания
и не могут начинаться с цифры.
.sic
Идентификаторы, начинающиеся с подчеркивания и состоящие только из
заглавных букв, зарезервированы для внутреннего использования интерпретатором.
..
В идентификаторах различается верхний и нижний регистры букв.

Строковые литералы можно заключать в одинарные или двойные кавычки.
В них можно использовать следующие специальные последовательности символов:

.code
  \n     перевод строки (LF = 0x0a)            \a        bell
  \r     возврат каретки (CR = 0x0d)           \b        backspace
  \t     табуляция                             \f        form feed
  \\     символ обратной косой черты           \v        вериткальная табуляция
  \"     кавычка                               \[        левая квадратная скобка 
  \'     апостроф                              \]        правая квадратная скобка
  \ddd   символ с кодом ddd (десятичным)       \0        символ с кодом 0
..

.sic
Если в конце строки исходного файла стоит символ обратной косой черты,
то на следующей строке может быть продолжено определение строкового литерала,
в который в этом месте вставится символ новой строки.
..

Строковые литералы можно также заключать в двойные квадратные скобки ~~~[[....]]~~~.
В этом случае литерал может быть определен на нескольких строках
(символы перевода строки включаются в строковый литерал)
и в нем не интерпретируются специальные последовательности символов.
.sic
Если непосредственно после символов ~~~'[['~~~ идет перевод строки, то он
не включается в строковый литерал.
..
В качестве ограничителей строки кроме двойных квадратных скобок может использоваться
символ ~~~[===[ .... ]===]~~~ в котором между повторяющимися квадратными скобками
расположено произвольное число знаков равенства (одинаковое для открывающего
и закрывающего ограничителя).

В числовых константах можно указывать необязательную дробную часть
и необязательный десятичный порядок, задаваемый символами
~~~'e'~~~ или ~~~'E'~~~.
Целочисленные числовые константы можно задавать в 16-ричной системе,
используя префикс ~~~0x~~~.

Комментарий начинается символами ~~~'--'~~~ (два минуса подряд)
и продолжается до конца строки.
Если непосредственно после символов ~~~'--'~~~ идут символы ~~~'[['~~~,
то комментарий является многострочным и продолжается до символов ~~~']]'~~~.
Многострочный комментарий может содержать вложенные пары символов ~~~[[....]]~~~.
В качестве ограничителей многострочных комментариев кроме двойных квадратных скобок 
может также использоваться символ ~~~[===[ .... ]===]~~~ в котором между повторяющимися 
квадратными скобками расположено произвольное число знаков равенства (одинаковое для 
открывающего и закрывающего ограничителя).
Строковая константа экранирует символы начала комментария.

Если первая строка файла начинается с символа ~~~'#'~~~, то она пропускается.
Это позволяет использовать ~~~Lua~~~ как интерпретатор скриптов в Unix-подобных системах.

.sect "Типы данных"

В ~~~Lua~~~ имеются следующие типы данных:

.code
  nil           пусто
  boolean       логический
  number        числовой
  string        строковый
  function      функция
  userdata      пользовательские данные
  thread        поток
  table         ассоциативный массив
..

Тип ~~~nil~~~ соответствует отсутствию у переменной значения.
Этому типу соответствует единственное значение ~~~nil~~~.

Логический тип имеет два значения: ~~~true~~~ и ~~~false~~~.
.sic
Значение ~~~nil~~~ рассматривается как ~~~false~~~.
Все остальные значения, включая число ~~~0~~~ и пустую строку,
рассматриваются как логическое значение ~~~true~~~.
..

Все числа представлены как вещественные числа двойной точности.

.sic
Строки представляют собой массивы 8-битных символов и могут
содержать внутри себя символ с нулевым кодом.
Все строки в ~~~Lua~~~ константные т.е.
изменить содержимое существующей строки нельзя.
..

Функции можно присваивать переменным, передавать в функции в качестве аргумента,
возвращать в качестве результата из функции и сохрнять в таблицах.

Тип ~~~userdata~~~ соответствует нетипизированному указателю,
по которому могут быть расположеы произвольные данные.
Программа на ~~~Lua~~~ не может непосредственно работать
с такими данными (создавать, модифицировать их).
Этому типу данных не соответствует никаких предопределенных операций кроме
присваивания и сравнения на равенство.
В то же время такие операции могут быть определены при помощи механизма метаметодов.

Тип ~~~thread~~~ соответствует независимо выполняемому потоку.
Этот тип данных используется механизмом сопрограмм.

Тип ~~~table~~~ соответствует таблицам --- ассоциативным массивам,
которые можно индексировать любыми значениями
и которые могут одновременно содержать значения произвольных типов.

Тип объекта, сохраненного в переменной можно выяснить, вызвав функцию ~~~type()~~~.
Эта функция возвращает строку, содержащую каноническое название типа:
~~~"nil", "number", "string", "boolean", "table", "function", "thread", "userdata"~~~.

Преобразования между числами и строками происходят автоматически
в момент их использования в соответствующем контексте.
.sic
Арифметические операции подразумевают числовые аргументы
и попытка выполнить такую операцию над строками приведет к преобразованию
их в числа.
Строковые операции, производимые над числами, приводят к их
преобразованию в строку с помощью некоторого фиксированного форматного
преобразования.
..
Можно также явно преобразовать объект в строку с помощью
функции ~~~tostring()~~~ или в число с помощью функции ~~~tonumber()~~~.
Для большего контроля над процессом преобразования чисел в строки
следует использовать функцию форматного преобразования.

.sect "Переменные"

В ~~~Lua~~~ переменные не нужно описывать.
Переменная появляется в момент ее первого использования.
Если используется переменная, которая не была предварительно
инициализирована, то она имеет значение ~~~nil~~~.
Переменные не имеют статического типа, тип переменной определяется
ее текущим значением.

Переменная считается глобальной, если она явно не объявлена как локальная.
Объявление локальных переменных может быть расположено в любом месте блока
и может быть совмещено с их инициализацией:

.code
  local x, y, z
  local a, b, c = 1, 2, 3
  local x = x
..

При инициализации локальной переменной справа от знака равенства
вводимая переменная еще не доступна и используется значение переменной,
внешней по отношению к текущему блоку.
Именно поэтому корректен пример в третьей строке (он демонстрирует часто
используемую идиому языка).

Для локальных переменных интерпретатор использует лексические области
видимости т.е. область действия переменной простирается от места ее описания
(первого использования) и до конца текущего блока.
При этом локальная переменная видима в блоках, внутренних
по отношению к блоку, в котором она описана.
Локальная переменная исчезает при выходе из области видимости.
Если локальная переменная определена вне блока, то такая переменная исчезает
по окончании исполнения этого участка кода, поскольку участок кода
выполняется интерпретатором как безымянная функция.
Инициализированная глобальная переменная существует все время функционирования
интерпретатора.
.sic
Для удаления переменной ей можно просто присвоить значение ~~~nil~~~.
..

Массивы, функции и ~~~userdata~~~ являются объектами.
Все объекты анонимны и не могут быть значением переменной.
.sic
Переменные хранят ссылки на объекты.
При присваивании, передаче в функцию в качестве аргумента и возвращении
из функции в качестве результата не происходит копирование объектов,
копируются только ссылки на них.
..

.sect "Таблицы"

Таблицы (тип ~~~table~~~) соответствует ассоциативным массивам,
которые можно индексировать любыми значениями кроме ~~~nil~~~
и которые могут одновременно содержать значения произвольных типов
кроме ~~~nil~~~.
Элементы таблицы можно индексировать и объектами --- таблицами, функциями
и объектами типа ~~~userdata~~~.
Элементы массива, не получившие значения в результате присваивания,
имеют по умолчанию значение ~~~nil~~~.

Таблицы --- основная структура данных в ~~~Lua~~~.
С их помощью представляются также структуры, классы и объекты.
В этом случае используется индексирование строковым именем поля структуры.
Поскольку элементом массива может быть функция, в структурах допускаются также
и методы.

Для индексирования массивов используются квадратные скобки:
~~~array[index]~~~.
Запись ~~~struct.field~~~ эквивалентна следующей записи:
~~~struct["field"]~~~.
Эта синтаксическая особенность позволяет использовать таблицы
в качестве записей с поименованными полями.

Конструктор таблицы --- это выражение, создающее и возвращающее новую таблицу.
Каждое выполнение конструктора создает новую таблицу.
Конструктор таблицы представляет собой заключенный в фигурные скобки
список инициализаторов полей (возможно пустой),
разделенных запятой или символом ~~~';'~~~ (точка с запятой).
Для инициализаторов полей допустимы следующие варианты:

.code
  [exp1] = exp2               table[exp1] = exp2
  name = exp                  table["name"] = exp
  exp                         table[j] = exp
..

В последнем случае переменная ~~~j~~~ пробегает последовательные
целые значения, начиная с ~~~1~~~.
Инициализаторы первых двух видов не изменяют значение этого счетчика.
Вот пример конструирования таблицы:

.code
  x = { len = 12, 11, 12, [123] = 1123 }
..

После выпонения такого оператора поля таблицы получат следующие значения:

.code
  x["len"] = x.len = 12
  x[1] = 11
  x[2] = 12
  x[123] = 1123
..

# списки
Если последним элементом списка инициализаторов является вызов функции,
то возвращаемые функцией значения последовательно помещаются в список
инициализаторов.
Это поведение можно изменить, заключив вызов функции в круглые скобки.
В этом случае из всех возвращаемых функцией значений используется
только первое.
# списки

После последнего инициализатора может идти необязательный символ-разделитель
инициализаторов полей (запятая или точка с запятой).

.sect "Операции"

Ниже перечислены основные операции:

.code
  -            смена знака
  + - * /      арифметика
  ^            возведение в степень

  == ~=        равенство

  < <= > >=    порядок

  not and or   логика

  ..           конкатенация строк
  #            получение длины строки или массива
..

При применении арифметических операций строки, имеющие числовое значение,
приводятся к нему.
При конкатенации числовых значений они автоматически преобразуются в строки.

.sic
При сравнении на равенство не производится преобразование типов.
Объекты разных типов всегда считаются различными.
..
Соответственно ~~~"0" ~= 0~~~, а при индексировании
~~~a[0]~~~ и ~~~a["0"]~~~ соответствуют разным ячейкам массива.
При сравнении на равенство/неравенство объектов производится
сравнение ссылок на объекты.
Равными оказываются переменные, ссылающиеся на один и тот же объект.

При выяснении порядка типы аргументов должны совпадать, т.е.
числа сравниваются с числами, а строки --- со строками.

Отношения равенства и порядка всегда дают в результате
~~~true~~~ или ~~~false~~~ т.е. логическое значение.

.sic
В логических операциях ~~~nil~~~ рассматривается как ~~~false~~~,
а все остальные значения, включая нулевое число и пустую строку --- как
~~~true~~~.
..
При вычислении значения используется короткая схема ---
второй аргумент вычисляется только если это необходимо.

Действует следующая таблица приоритетов и ассоциативности операций:

.code
  [right]    ^
  [left]     not   #     -(unary)
  [left]     *     /
  [left]     +     -
  [left]     <     >     <=     >=     ~=     ==
  [right]    ..
  [left]     and
  [left]     or
..

.sect "Логические операции и связанные с ними идиомы"

Оператор ~~~not~~~ всегда возвращает логическое значение,
принимая аргумент произвольного типа (при этом только значение
~~~nil~~~ соответствует логическому значению ~~~false~~~,
остальные же трактуются как ~~~true~~~).
В отличие от него операторы ~~~and~~~ и ~~~or~~~
всегда возвращают один из своих аргументов.
Оператор ~~~or~~~ возвращает свой первый аргумент,
если его значение отлично от ~~~false~~~ и ~~~nil~~~
и второй аргумент в противном случае.
Оператор ~~~and~~~ возвращает свой первый аргумент,
если его значение равно ~~~false~~~ или ~~~nil~~~
и второй аргумент в противном случае.
Такое поведение основано на том, что все значения, отличные от ~~~nil~~~,
трактуются как ~~~true~~~.

С этим поведением связано несколько общеупотребительных идиом.
В следующей таблице слева приведена идиоматическая операция, а справа ---
эквивалентная обычная запись:

.code
  x = x or v                if x == nil then x = v end
  x = (e and a) or b        if e ~= nil then x = a else x = b end
..

Первая идиома часто используется для присвоения неинициализированной переменной
умалчиваемого значения.
Вторая идиома эквивалентна C'шному оператору ~~~x = e ? a, b~~~
(здесь считается, что значение переменной ~~~a~~~
отлично от ~~~nil~~~).

.sect "Операторы"

В ~~~Lua~~~ нет выделенной функции, с которой начинается
выполнение программы.
Интерпретатор последовательно выполняет операторы,
которые он получает из файла или от управляющей программы.
При этом он предварительно компилирует программу в двоичное представление,
которое также может быть сохранено.
Любой блок кода выполняется как анонимная функция,
поэтому в нем можно определять локальные переменные
и из него можно возвращать значение.

Операторы можно (но не обязательно) разделять символом ~~~';'~~~.

Допускается множественное присваивание:

.code
  var1, var2 = val1, val2
..

При этом производится выравнивание ---
лишние значения отбрасываются, а переменным, соответствующим
недостающим значениям присваивается значение ~~~nil~~~.
Все выражения, входящие в правую часть множественного присваивания,
вычисляются до самого присвоения.

Если функция возвращает несколько значений, то
с помощью множественного присваивания
можно получить возвращаемые значения:

.code
  x, y, z = f();
  a, b, c, d = 5, f();
..

# списки
В общем случае если в конце списка значений,
расположенного справа от знака присваивания,
находится вызов функции, то все значения,
возвращаемые функцией, дописываются в конец списка значений.
Это поведение можно изменить, заключив вызов функции в круглые скобки.
В этом случае из всех возвращаемых функцией значений используется
только первое.
# списки

Ниже перечислены основные операторы:

.code
  do ... end

  if ... then ... end
  if ... then ... else ... end
  if ... then ... elseif ... then ... end
  if ... then ... elseif ... then ... else ... end

  while ... do ... end
  repeat ... until ...

  for var = start, stop do ... end
  for var = start, stop, step do ... end

  return
  return ...
  break
..

Блок ~~~do ... end~~~ превращает последовательность операторов
в один оператор и открывает новую область видимости, в которой можно
определять локальные переменные.

В операторах ~~~if~~~, ~~~while~~~ и ~~~repeat~~~
все значения выражения, отличные от ~~~false~~~ и ~~~nil~~~
трактуются как истинные.

Вот общая форма записи оператора ~~~if~~~:

.code
  if ... then ... {elseif ... then ...} [else ...] end
..

Оператор ~~~return~~~ может не содержать возвращаемых значений
или содержать одно или несколько выражений (список).
Поскольку блок кода выполняется как ананимная функция,
возвращаемое значение может быть не только у функции,
но и у произвольного блока кода.

Операторы ~~~return~~~ и ~~~break~~~ должны быть последними
операторами в блоке (т.е. должны быть либо последними операторами в блоке кода,
либо распологаться непосредственно перед словами ~~~end~~~,
~~~else~~~, ~~~elseif~~~, ~~~until~~~).
Внутри блока необходимо использовать идиому ~~~do return end~~~ или
~~~do break end~~~.

Оператор ~~~for~~~ выполняется для всех значений переменной цикла
начиная от стартового значения и кончая финишным значением включительно.
Третье значение, если оно задано, используется как шаг изменения переменной цикла.
Все эти значения должны быть числовыми.
Они вычисляются только однажды перед выполнением цикла.
Переменная цикла локальна в этом цикле и не доступна вне его тела.
Значение переменной цикла нельзя изменять внутри тела цикла.
Вот псевдокод, демонстрирующий выполнение оператора ~~~for~~~:

.code
  do
    local var, _limit, _step = tonumber(start), tonumber(stop), tonumber(step)
    if not (var and _limit and _step) then error() end
    while (_step>0 and var<=_limit) or (_step<=0 and var>=_limit) do
      ...
      var = var + _step
    end
  end
..

.sect "Функции"

Определение функции --- это исполняемое выражение (конструктор функции),
результатом вычисления которого является объект типа функция:

.code
  f = function( ... ) ... end
..

В скобках размещается список (возможно пустой) аргументов функции.
Список аргументов функции может заканчиваться троеточием ---
в этом случае функция имеет переменное число аргументов.
Между закрывающейся скобкой и оператором ~~~end~~~ размещается тело функции.

Для определения функции имеются следующие краткие формы:

.code
  function fname( ... ) ... end             fname = function( ... ) ... end
  local function fname( ... ) ... end       local fname = function( ... ) ... end
  function x.fname( ... ) ... end           x.fname = function( ... ) ... end
  function x:fname( ... ) ... end           x.fname = function( self, ... ) ... end
..

В момент выполнения конструктора функции строится также ___замыкание___ ---
таблица всех доступных в функции и внешних по отношению к ней локальных переменных.
Если функция передается как возвращаемое значение, то она сохраняет
доступ ко всем переменным, входящим в ее замыкание.
При каждом выполнения конструктора функции строится новое замыкание.

Вызов функции состоит из ссылки на функцию и заключенного в круглые скобки
списка аргументов (возможно пустого).
Ссылкой на функцию может быть любое выражение, результатом вычисления которого
является функция.
Между ссылкой на функцию и открывающейся круглой скобкой не может быть
перевода строки.

Для вызова функций имеются следующие краткие формы:

.code
  f{...}             f({...})
  f('...')           f'...'
  f("")              f""
  f([[...]])         f[[...]]
  x:f(...)           x.f(x, ...)
..

В первом случае единственным аргументом является конструируемая на лету таблица,
а в следующих трех --- строковый литерал.
В последнем случае ~~~x~~~ используется как таблица, из которой
извлекается переменная ~~~f~~~, являющаяся ссылкой на вызываемую
функцию и эта же таблица передается в функцию в качестве первого аргумента.
Эта синтаксическая особенность используется для реализации объектов.

При вызове функции значения простых типов копируются в аргументы по значению,
а для объектов в аргументы копируются ссылки.
При вызове функции производится выравнивание числа аргументов ---
лишние значения отбрасываются, а аргументы, соответствующие
недостающим значениям получают значение ~~~nil~~~.
# списки
Если в конце списка параметров стоит вызов функции, возвращающей
несколько значений, то все они добавляются в список аргументов.
Это поведение можно изменить, заключив вызов функции в круглые скобки.
В этом случае из всех возвращаемых функцией значений используется
только первое.
# списки

Если функция имеет переменное число аргументов, то значения,
не поставленные в соответствие ни одному из аргументов,
могут быть получены при использовании специфического имени ~~~...~~~.
# списки
Это имя ведет себя как набор значений, возвращаемых функцией т.е.
при его появлении внутри выражения или из середины списка значений
используется только первое возвращаемое значение.
Если же имя ~~~...~~~ оказывается в последней позиции списка значений
(в конструкторах таблиц, при множественном присваивании,
в списке аргументов при вызове функции и в операторе ~~~return~~~),
то все возвращаемые значения помещаются в конец этого списка
(правило дополнения списков).
Для подавления такого поведения имя ~~~...~~~ может быть помещено в круглые скобки.
# списки
Превратить набор значений в список можно с помощью идиомы ~~~{...}~~~.

Если функция принимает единственный аргумент и трактует его как таблицу,
элементы которой индексируются именами формальных параметров функции,
то в этом случае фактически реализуется вызов механизм поименованных аргументов:

.code
  function rename( arg )
    arg.new = arg.new or arg.old .. ".bak"
    return os.rename(arg.old, arg.new)
  end

  rename{ old = "asd.qwe" }
..

Возврат из функции происходит как при завершении выполнения ее тела,
так и при выполнении оператора ~~~return~~~.
Оператор ~~~return~~~ может возвращать одно или несколько
значений.
# списки
Если в конце списка возвращаемых значений стоит вызов функции, возвращающей
несколько значений, то все они добавляются в список аргументов.
Это поведение можно изменить, заключив вызов функции в круглые скобки.
В этом случае из всех возвращаемых функцией значений используется
только первое.
# списки

Если функция вызывается как оператор, то все возвращаемые значения уничтожаются.
# списки
Если функция вызывается из выражения или из середины списка значений,
то используется только первое возвращаемое значение.
Если же функция вызывается из последней позиции списка значений
(в конструкторах таблиц, при множественном присваивании,
в списке аргументов при вызове функции и в операторе ~~~return~~~),
то все возвращаемые значения помещаются в конец этого списка
(правило дополнения списков).
Для подавления такого поведения вызов функции может быть помещен в круглые скобки.
# списки

Имеется предопределенная функция ~~~unpack()~~~, которая принимает
массив, элементы которого проиндексированы с ~~~1~~~,
а возвращает все его элементы.
Эта функция может быть использована для вызова функций, принимающих
переменное число аргументов с динамическим формированием списка
фактических аргументов.
Обратная операция производится следующим образом:
.code
  list1 = {f()}  -- создать список из всех значений, возвращенных функцией f()
  list2 = {...}  -- создать список из всех значений, переданных в функцию
                    с переменным числом аргументов
..

Переменное число возвращаемых значений, правило дополнения списков
и возможность передавать в функцию не все формальные параметры
могут взаимодействовать нетривиальным образом.
Часто функция (например ~~~foo()~~~) возвращает ответ
при нормальном завершении и ~~~nil~~~ и сообщение об ошибке
при ненормальном.
Функция ~~~assert(val, msg)~~~ генерирует ошибку с сообщением ~~~message~~~
(вызывая функцию ~~~error(msg)~~~)
если ~~~val~~~ имеет значение ~~~false~~~ или ~~~nil~~~
и возвращает значение ~~~val~~~ в противном случае.
Тогда оператор
.code
  v = assert(foo(), "message")
..
в случае успеха присваивает переменной ~~~v~~~ значение,
возвращаемое функцией ~~~foo()~~~.
В этом случае ~~~foo()~~~ возвращает одно значение,
а ~~~assert()~~~ получает параметр ~~~msg~~~, равный ~~~nil~~~.
В случае ошибки функция ~~~assert()~~~ получает ~~~nil~~~
и сообщение об ошибке.

.sect "Итераторы"

Итераторы используются для перечисления элементов произвольных последовательностей:

.code
  for v_1, v_2, ..., v_n in explist do ... end
..

Число переменных в списке ~~~v_1, ..., v_n~~~ может быть произвольным
и не обязано соответствовать числу выражений в списке ~~~explist~~~.
В роли ~~~explist~~~ обычно выступает вызов фунции-фабрики итераторов.
Такая функция возвращает функцию-итератор, состояние и начальное значение
управляющей переменной цикла.
Итератор интерпретируется следующим образом:

.code
  do
    local f, s, v_1 = explist
    local v_2, ... , v_n
    while true do
      v_1, ..., v_n = f(s, v_1)
      if v_1 == nil then break end
      ...
    end
  end
..

На каждом шаге значения всех переменных ~~~v_k~~~ вычисляются
путем вызова функции-итератора.
Значение управляющей переменной ~~~v_1~~~ управляет завершением цикла ---
цикл завершается как только функция-итератор возвратит ~~~nil~~~
как значение для переменной ~~~var_1~~~.

Фактически итерациями управляет переменная ~~~v_1~~~,
а остальные переменные можно рассматривать как <<<хвост>>>,
возвращаемый функцией-итератором:

.code
  do
    local f, s, v = explist
    while true do
      v = f(s, v)
      if v == nil then break end
      ...
    end
  end
..

Оператор, в котором вызывается функция-фабрика, интерпретируется как обычный
оператор присваивания т.е. функция-фабрика может возвращать произвольное
количество значений.

.subs "Итераторы без внутреннего состояния"

Итератор без внутреннего состояния не хранит никакой внутренней информации,
позволяющей ему определить свое положение в итерируемом контейнере.
Следующее значение управляющей переменной вычисляется непосредственно
по ее предыдущему значению, а состояние используется для хранения
ссылки на итерируемый контейнер.
Вот пример простого итератора без внутреннего состояния:

.code
  function iter( a, i )
    i = i + 1
    local v = a[i]
    if v then
      return i, v
    else
      return nil
    end
  end

  function ipairs( a )
    return iter, a, 0
  end
..

.subs "Итераторы, хранящие состояние в замыкании"

Если итератору для обхода контейнера необходимо внутреннее состояние,
то проще всего хранить его в замыкании, создаваемом по контексту
функции-фабрики.
Вот простой пример:

.code
  function ipairs( a )
    local i = 0
    local t = a

    local function iter()
      i = i + 1
      local v = t[i]
      if v then
        return i, v
      else
        return nil
      end
    end

    return iter
  end
..

Здесь итератор хранит весь контекст в замыкании и не нуждается
в состоянии и текущем значении управляющей переменной.
Соответственно, итератор не принимает состояние и управляющую переменную,
а фабрика не возвращает значение состояния и
стартовое значение управляющей переменной.

.subs "Стандартные итераторы"

Чаще всего итераторы применяются для обхода элементов таблиц.
Для этого существует несколько предопределенных функций-фабрик итераторов.
Фабрика ~~~pairs(t)~~~ возвращает итератор, дающий на каждом шаге
индекс в таблице и размещенное по этому индексу значение:

.code
  for idx, val in pairs(tbl) do
    ...
  end
..

На самом деле этот итератор легко определить, используя стандартную
функцию ~~~next(tbl, idx)~~~:

.code
  function pairs(tbl)
    return next, tbl, nil
  end
..

Функция ~~~next(tbl, idx)~~~ возвращает следующее за ~~~idx~~~
значение индекса при некотором обходе таблицы ~~~tbl~~~
(вызов ~~~next(tbl, nil)~~~ возвращает начальное значение индекса;
после исчерпания элементов таблицы возвращается ~~~nil~~~).

Фабрика ~~~ipairs(tbl)~~~ возвращает итератор,
работающий совершенно аналогично описанному выше,
но предназначенный для обхода таблиц,
проиндексированные целыми числами начиная с ~~~1~~~.

.sect "Мета-таблицы"

Каждая таблица и объект типа ~~~userdata~~~
могут иметь мета-таблицу --- обычную таблицу, поля которой
определяют поведение исходного объекта при применении
к нему некоторых специальных операций.
Например, когда объект оказывается операндом при сложении,
интерпретатор ищет в мета-таблице поле с именем ~~~__add~~~ и,
если такое поле присутствует, то использует его значение
как функцию, выполняющую сложение.
Мета-таблицы позволяют определить поведение объекта при
арифметических операциях, сравнениях, конкатенации и индексировании.
Также можно определить функцию, вызываемую при освобождении объекта
типа ~~~userdata~~~.
Индексы (имена полей) в мета-таблице называются ___событиями___,
а соответствующие значения (обработчики событий) --- ___метаметодами___.

По умолчанию вновь созданная таблица не имеет мета-таблицы.
Любую таблицу ~~~mt~~~ можно сделать мета-таблицей
таблицы ~~~t~~~, вызвав функцию ~~~setmetatable(t, mt)~~~.
Функция ~~~getmetatable(t)~~~ возвращает мета-таблицу таблицы ~~~t~~~
или ~~~nil~~~, если таблица не имеет мета-таблицы.
Любая таблица может выполнять роль мета-таблицы для любой другой таблицы,
в том числе и для себя.

Lua определяет следующие события:

.code
  __add, __sub, __mul, __div      арифметические операции
  __pow                           возведение в степень
  __unm                           унарный минус
  __concat                        конкатенация
  __eq, __lt, __le                операции сравнения
  __index                         доступ по отсутствующему индексу
  __newindex                      присвоение новому элементу таблицы
  __call                          вызов функции
  __tostring                      преобразование в строку
  __metatable                     получения мета-таблицы
..

Выражение ~~~a ~= b~~~ вычисляется как ~~~not (a == b)~~~.
Выражение ~~~a > b~~~ вычисляется как ~~~b < a~~~.
Выражение ~~~a >= b~~~ вычисляется как ~~~b <= a~~~.
При отсутствии метаметода ~~~__le~~~ операция ~~~<=~~~
вычисляется как ~~~not (b < a)~~~ т.е.
с помощью метаметода ~~~__lt~~~.

Для бинарных операций выбор обработчика производится следующим образом:
опрашивается первый операнд и, если он не определяет обработчик,
то опрашивается второй операнд.
Для операций сравнения метаметод выбирается только если
сравниваемые операнды имеют одинаковый тип и одинаковый
метаметод для выполнения этой операции.
В руководстве пользователя приведен псевдокод на ~~~Lua~~~,
демонстрирующий контекст вызова метаметодов.

Обработчик события ~~~__index~~~ может быть функцией или таблицей.
В случае функции обработчик вызывается и ему передается таблица и значение индекса.
Такая функция должна возвращать результат индексирования.
В случае таблицы происходит повторное индексирование этой таблицы тем же индексом.
Если присутствует обработчик события ~~~__newindex~~~, то он вызывается
вместо присвоения значения новому элементу таблицы.
Если этот обработчик является таблицей, то присвоение производится в этой таблице.

Метаметод ~~~__tostring~~~ позволяет обработать преобразование
объекта (таблицы или ~~~userdata~~~) в строку.
Метаметод ~~~__metatable~~~ позволяет обработать операцию получения
мета-таблицы.
Если у этого поля в мета-таблице установлено значение, то
функция ~~~getmetatable()~~~ будет возвращать значение этого поля,
а функция ~~~setmetatable()~~~ будет завершаться с ошибкой.

Функция ~~~rawget(tbl, idx)~~~ позволяет прочитать поле таблицы
в обход механизма мета-методов.
Аналогичный доступ на запись предоставляет функция ~~~rawset(tbl, idx, val)~~~.
Функция ~~~rawequal(t1, t2)~~~ сравнивает объекты в обход механизма мета-методов.

.sect "Примеры использования мета-таблиц"

.subs "Значение по умолчанию для полей таблиц"

В следующем примере мета-таблицы используются для назначения
значения по умолчанию для отсутствующих элементов таблицы:

.code
  function set_def(t, v)
    local mt = { __index = function() return v end }
    setmetatable(t, mt)
  end
..

Вот более нетривиальное решение, которое не использует отдельной мета-таблицы
для каждого умалчиваемого значения:

.code
  local key = {}
  local mt = { __index = function(t) return t[key] end }

  function set_def(t, v)
    t[key] = v
    setmetatable(t, mt)
  end
..

Здесь локальная (пустая) таблица ~~~key~~~ используется как заведомо уникальный
индекс, по которому в исходной таблице ~~~t~~~ сохраняется
умалчиваемое значение ~~~v~~~.
Все таблицы, для которых устанавливается умалчиваемое значение
отсутствующих полей, разделяют общую мета-таблицу ~~~mt~~~.
Мета-метод ~~~__index~~~ этой мета-таблицы перехватывает обращения к
отсутствующим полям таблицы и возвращает значение, сохраненное
в самой таблице по индексу ~~~key~~~.

У этого решения есть недостаток: в таблице появляется новая пара ключ-значение,
которая проявится при попытке обойти все элементы таблицы.

.subs "Таблица-прокси"

В следующем примере пустая таблица выполняет роль прокси,
переадресующего обращения к полям таблицы:

.code
  local key = {}
  local mt = {
    __index = function(t,k)
      return t[key][k]
    end,
    __newindex = function(t,k,v)
      t[key][k] = v
    end
  }

  function proxy(t)
    local proxy = {}
    proxy[key] = t
    setmetatable(proxy, mt)
    return proxy
  end
..

Здесь локальная (пустая) таблица ~~~key~~~ используется как заведомо уникальный
индекс, по которому в таблице-прокси сохраняется ссылка на
исходную таблицу ~~~t~~~.
Прокси представляет собой таблицу, единственный элемент которой имеет
индекс ~~~key~~~, поэтому обращение к любому элементу прокси
приведет к вызову мета-метода.
Общая для всех прокси мета-таблица определяет мета-методы ~~~__index~~~
и ~~~__newindex~~~, извлекающие исходную таблицу из единственного
элемента прокси, индексируя его таблицей ~~~key~~~.

Мета-методы могут обеспечить произвольную дисциплину обработки
обращений к полям исходной таблицы.
Простыми примерами является протоколирование обращений или
генерирование ошибки при попытке изменить значение элемента таблицы.

.sect "<<<Слабые>>> таблицы"

Если объект был использован как индекс таблицы или ссылка на него
была сохранена в таблице, то сборщик мусора не сможет утилизировать
такой объект.
В то же время, в некоторых случаях желательно иметь таблицу,
в которой связь ее элементов с ключами и/или значениями <<<слабая>>>
т.е. не препятствующая сбору мусора.
Обычно такая необходимость возникает при кэшировании результатов
вычислений в таблице и сохранении атрибутов объектов в таблице,
проиндексированной самими объектами.
В первом случае желательна слабая связь для значений, во втором ---
для индексов.

Связь элементов таблицы с объектами (значениями и индексами)
определяется значением строкового поля ~~~__mode~~~ ее мета-таблицы.
Если это поле содержит символ ~~~'k'~~~, то слабой делается связь
для индексов (ключей); если оно содержит символ ~~~'v'~~~, то слабой
делается связь для значений.
Поле может содержать оба символа, что сделает слабой связь как для индексов,
так и для значений.

Если использовать слабые таблицы, то для рассмотренной выше задачи
сопоставления таблице умалчиваемого значения для отсутствующих полей
можно привести следующее решение:

.code
  local defaults = {}
  setmetatable(defaults, { __mode = "k" })
  local mt = { __index = function(t) return defaults[t] end }

  function set_def(t, d)
    defaults[t] = d
    setmetatable(t, mt)
  end
..

Вот другое решение, в котором слабая таблицы хранит мета-таблицы,
количество которых совпадает с числом различных умалчиваемых значений:

.code
  local metas = {}
  setmetatable(metas, { __mode = "v" })

  function set_def(t, d)
    local mt = metas[d]
    if mt == nil then
      mt = { __index = function () return d end }
      metas[d] = mt
    end
    setmetatable(t, mt)
  end
..

.sect "Глобальный контекст"

Все глобальные переменные являются полями обычной таблицы,
называемой ___глобальным контекстом___.
Эта таблица доступна через глобальную переменную ~~~_G~~~.
Поскольку все глобальные переменные являются полями контекста,
то ~~~_G._G == _G~~~.

Глобальный контекст делает возможным доступ к глобальным переменным
по динамически генерируемому имени:

.code
  val = _G[varname]
  _G[varname] = val
..

Поскольку глобальный контекст является обычной таблицей,
ему может соответствовать мета-таблица.
В следующем примере переменные окружения вводятся в глобальную область
видимости как глобальные переменные, доступные только для чтения:

.code
  local f = function (t,i)
    return os.getenv(i)
  end

  setmetatable(_G, {__index=f})
..

Этот же прием позволяет запретить доступ к неинициализированным глобальным
переменным.

.sect "Пакеты"

Пакеты --- основной способ определять набор взаимосвязанных функций,
не загрязняя при этом глобальную область видимости.
Обычно пакет представляет собой отдельный файл, который в глобальной области
видимости определяет единственную таблицу, содержащую все функции этого пакета:

.code
  my_package = {}
      
  function my_package.foo()
    ...
  end
..

Также можно делать все функции локальными и отдельно формировать таблицу
экспортируемых функций:

.code
  local function foo() ... end
  local function bar() ... end

  my_package = {
    foo = foo,
    bar = bar,
  }
..

Пакет загружается с помощью функции ~~~require()~~~, причем во время загрузки
имя, переданное этой функции (оно может не содержать расширения, которое
добавляется автоматически) доступно через переменную ~~~_REQUIREDNAME~~~:

.code
  if _REQUIREDNAME == nil then
    run_some_internal_tests()
  end
..

.sect "Классы и объекты"

Конструкция ~~~tbl:func()~~~ (при объявлении функции и при ее вызове)
предоставляет основные возможности, позволяющие работать с таблицей как с объектом.
Основная проблема состоит в порождении многих объектов, имеющих сходное
поведение т.е. порожденных от одного класса:

.code
  function class()
    cl = {}
    cl.__index = cl            -- cl будет использоваться как мета-таблица
    return cl
  end

  function object( cl, obj )
    obj = obj or {}            -- возможно уже есть заполненные поля
    setmetatable(obj, cl)
    return obj
  end
..

Здесь функция ~~~class~~~ создает пустую таблицу, подготовленную к тому,
чтобы стать мета-таблицей объекта.
Методы класса делаются полями этой таблицы т.е. класс является таблицей,
одновременно содержащей методы объекта и его мета-методы.
Функция ~~~object()~~~ создает объект заданного класса --- таблицу,
у которой в качестве мета-таблицы установлен заданный класс.
Во втором аргументе может быть передана таблица, содержащая
проинициализированные поля объекта.

.code
  Some_Class = class()

  function Some_Class:foo() ... end

  function Some_Class:new()
    return object(self, { xxx = 12 })
  end

  x = Some_Class:new()

  x:foo()
..

.subs "Наследование"

В описанной реализации мета-таблица класса остается не использованной,
что делает простой задачу реализации наследования.
Класс-наследник создается как объект класса, после чего в нем
устанавливающая поле ~~~__index~~~ таким образом, чтобы его можно было
использовать как мета-таблицу:

.code
  function subclass( pcl )
    cl = pcl:new()           -- создаем экземпляр
    cl.__index = cl          -- и делаем его классом
    return cl
  end
..

Теперь в полученный класс-наследник можно добавить новые поля и методы:

.code
  Der_Class = subclass(Some_Class)

  function Der_Class:new()
    local obj = object(self, Some_Class:new())
    obj.yyy = 13                      -- добавляем новые поля
    return obj
  end

  function Der_Class:bar() ... end    -- и новые методы

  y = Der_Class:new()

  y:foo()
  y:bar()
..

Единственный нетривиальный момент здесь состоит в использовании
функции ~~~new()~~~ из класса-предка с последующей заменой мета-таблицы
посредством вызова функции ~~~object()~~~.

При обращении к методам объекта класса-наследника
в первую очередь происходит их поиск в мета-таблице т.е.
в самом классе-наследнике.
Если метод был унаследован, то этот поиск окажется неудачным и произойдет
обращение к мета-таблице класса-наследника т.е. к классу-предку.

Основной недостаток приведенного общего решения состоит в невозможности
передачи параметров в функцию ~~~new()~~~ класса-предка.

.sect "Аргументы командной строки"

Переданные при запуске аргументы командной строки доступны
как элементы массива ~~~arg~~~.

######################################
#  _TRACEBACK function:
#  newproxy function:
#  API (3)
#  Garbage Collection (2.9)
#  Coroutines (2.10, 5.2)
#  Debug Interface (4, 5.8)
######################################
